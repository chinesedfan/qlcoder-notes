const data = [
    [' ', 100], [',', 7], ['.', 10], ['a', 36], ['b', 3], ['c', 8], ['d', 18],
    ['e', 42], ['f', 6], ['g', 13], ['h', 40], ['i', 31], ['j', 1], ['k', 3],
    ['l', 25], ['m', 11], ['n', 36], ['o', 23], ['p', 3], ['q', 1], ['r', 20],
    ['s', 25], ['t', 45], ['u', 3], ['v', 1], ['w', 14], ['x', 1], ['y', 5],
    ['z', 1]
];

const sorted = data
    .map((arr) => ({key: arr[0], val: arr[1]}))
    .sort((a, b) => a.val - b.val); // incremental
const same = []; // whose left and right has the same weight

while (sorted.length > 1) {
    // merge
    const a = sorted.shift();
    const b = sorted.shift();
    const c = {val: a.val + b.val, left: a, right: b};
    if (c.left.val === c.right.val) {
        same.push(c);
    }

    // insert
    let i = 0;
    while (i < sorted.length && sorted[i].val <= c.val) i++;
    sorted.splice(i, 0, c);
}

const code = '1001111111100111111010011110110011111000101001110110010111110000110010001110101111011100001011111111001000101010010001010111100110100110011100111000011011000111010011010110011111011110101100011110101100100111111000010110111000010001000010101111011100001011101101010010001111100110101110011101000011001110011100010010110110001110101111001001110001011011100001000100001110100011111010110100101011110000110101111111110110111111110010111111001001001000101011110000100100010101001001011111111001111110100011101011110111000001010111100010011010110111010010010110001101101011001001110001011011100001000100000110111011000110000010101111000100110110001111001101101000100010101001000011010111101000101011110000110001001111011000100111011001001110001011011100001000100000100011110011110011010010001010100100010010011111010010001110001100111001110001111100011110010111101100100111001000110011001110101111010001010110111110110001001000011110100011101011110100100101000110001111101010101101010101011100100111001000110011001110101111010001101100011101001101011110111000001111010100011101011110100011011000010001000101110010011100100011001100111010111101001111110011111000110100111010111000111000111110111111100111000101001010010000110010000111101001011110001110101111010010011011110010010010111111100111010111101000100011101100101111100011101011100011100011111011110000111101001100010100111010111101001001010000110110101111111001110101111010010111111011000101000111010111000111000011011000111110101101010100111010111101000101010011011101111110001101110000101111111100111010111101000101101101111101010010010001110101110001110000110011111001100011000100100101001110101111010011000110110000100110011001111011111100011001111011010110010011100111110000100110110010011001101001100111001110000100011111111101101001000101010010001011111101010111101100000111011110001110101111010010100111011001011111000011011000111010011010111111111001111110111101100000111010110111010100101001110110010111110001000101010010001000010001000011101011110100101001110110010111110010100111011110001001101111011001111011100100011101011110100100010100101011011101110000001110101000110101111010111011011100001110101100110111101100110111101001100110010';

// loop all possible trees
let kind = 0;
const max = Math.pow(2, same.length);
while (kind < max) {
    console.log(`Case ${kind}:`);
    swap();
    print();
    swap(); // recover

    kind++;
}

function swap() {
    for (let i = 0; i < same.length; i++) {
        if (kind & (1 << i)) {
            const tmp = same[i].right;
            same[i].right = same[i].left;
            same[i].left = tmp;
        }
    }
}

function print() {
    const result = [];

    let n = sorted[0];
    for (let i = 0; i < code.length; i++) {
        n = code[i] === '0' ? n.left : n.right;
        if (n.key) {
            result.push(n.key);
            n = sorted[0];
        }
    }
    console.log(result.join(''));
}
